require "./spec_helper"

# Test struct for iPhone pA extraction
struct IPhonePakeStruct
  include TLV::Serializable

  @[TLV::Field(tag: 1)]
  property x : Bytes
end

describe "TLV iPhone pA Extraction" do
  it "correctly extracts EC point from iPhone's Pake1 message" do
    # Actual data from iPhone commissioning attempt
    # This is the pA value that's causing the error
    full_tlv = Bytes[
      0x15,             # Anonymous structure start
      0x30, 0x01, 0x41, # Context tag 1, length 65 bytes
      # 65-byte EC point starting with 0x04
      0x04, 0x08, 0x57, 0x41, 0x64, 0x3a, 0xfa, 0x3f, 0xb7, 0xe6, 0x96, 0xf5, 0xd6, 0x54, 0xe0, 0x97,
      0x65, 0x75, 0xbc, 0x42, 0x8d, 0x88, 0xda, 0xac, 0x3f, 0x2a, 0x17, 0x36, 0x07, 0x3c, 0x87, 0xe9,
      0xa3, 0x9b, 0xf0, 0x33, 0x7c, 0x42, 0x6f, 0xa0, 0x2c, 0x3c, 0x4b, 0x07, 0x2e, 0x4c, 0x20, 0x2c,
      0x02, 0xeb, 0xb3, 0x14, 0xfa, 0xd8, 0x5a, 0x80, 0x0d, 0x28, 0x8b, 0x29, 0xba, 0xd3, 0x06, 0x1b,
      0x1c,
      0x18, # End of structure
    ]

    # Deserialize
    result = IPhonePakeStruct.new(full_tlv)

    # Should extract just the 65-byte EC point, not the full 70-byte TLV structure
    puts "Extracted data size: #{result.x.size}"
    puts "First byte: 0x#{result.x[0].to_s(16).rjust(2, '0')}"
    puts "First 10 bytes: #{result.x[0, 10].hexstring}"

    result.x.size.should eq(65)
    result.x[0].should eq(0x04) # First byte must be 0x04 for EC point

    # Verify it's the actual EC point data, not the TLV wrapper
    expected_ec_point = Bytes[
      0x04, 0x08, 0x57, 0x41, 0x64, 0x3a, 0xfa, 0x3f, 0xb7, 0xe6, 0x96, 0xf5, 0xd6, 0x54, 0xe0, 0x97,
      0x65, 0x75, 0xbc, 0x42, 0x8d, 0x88, 0xda, 0xac, 0x3f, 0x2a, 0x17, 0x36, 0x07, 0x3c, 0x87, 0xe9,
      0xa3, 0x9b, 0xf0, 0x33, 0x7c, 0x42, 0x6f, 0xa0, 0x2c, 0x3c, 0x4b, 0x07, 0x2e, 0x4c, 0x20, 0x2c,
      0x02, 0xeb, 0xb3, 0x14, 0xfa, 0xd8, 0x5a, 0x80, 0x0d, 0x28, 0x8b, 0x29, 0xba, 0xd3, 0x06, 0x1b,
      0x1c,
    ]

    result.x.should eq(expected_ec_point)
  end
end
